package com.example.kotlin_flowexample

import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.launch

// Смысл Flow - Мы можем определить поток в корутине как поток значений, выдаваемых корутиной,
// которые вычисляются асинхронно.

// Один из способов создания потока в корутинах= это с помощью билдера потоков flow{}

// Чтобы отправить значение из потока, мы используем функцию emit(value: T), значение которой может
// быть любого типа. Как только мы создадим поток эмиттера, мы должны собрать эти испускаемые данные.
// Для сбора/получения данных используется функция collect{}
//

suspend fun main() = coroutineScope<Unit>{

    // синхронный поток
    launch {
        getUsers().forEach { user -> println(user) }
    }

    // асинхронный поток
    // Для управления объектами из потока в интерфейсе Flow есть ряд функций, одной из которых
    // является collect(). В качестве параметра она принимает функцию, в которую передает
    // эмитируемый объект из потока
    getUsersFlow().collect { user ->
        println(user)
        println("---------------------------------")
    }
    // Таким образом, программа не ждет, когда функция getUsersFlow возвратит все строки.
    // А получает строки по мере их отправки в поток через функцию emit().

}


// Для получения набора объектов мы могли бы в корутине возвращать коллекцию элементов, например, список List,
suspend fun getUsers(): List<String> {
    delay(1000L)  // имитация продолжительной работы
    return listOf("Tom", "Bob", "Sam")
    // Проблема таких коллекций в том, что они одномоментно возвращают все объекты. Например, если в
    // списке ожидается 1000 объектов, то соответственно пока функция getUsers() не возвратит список
    // из 1000 объектов (например, получая их из базы данных или из внешнего интернет-ресурса),
    // мы не сможем манипулировать объектами из этого списка.
}
//--------------------------------------------------------------------------------------------------
// Получение объектов потоком можно решить при помощи асинхронных потоков.
// Изменим пример применением асинхронных потоков
// Для создания асинхронного потока данных применяется интерфейс Flow. То есть по сути асинхронный
// поток - это объект Flow. Он типизируется типом тех данных, которые должны передаваться в потоке.
// В данном случае передаем строки, поэтому Flow типизируется типом String.
// При этом при определении функции-потока необязательно использовать модификатор suspend.
fun getUsersFlow(): Flow<String> = flow { // Для создания объекта Flow применяется специальная функция flow()
    val database = listOf("Tom", "Bob", "Sam")  // условная база данных
    var i = 1;
    for (item in database){
        delay(400L) // имитация продолжительной работы
        println("Emit $i item")
        // В цикле пробегаемся по этому списку и отправляем в поток текущий объект с помощью функции emit():
        //  Благодаря этому внешний код сможет получит переданное через emit() в поток значение и использовать его.
        emit(item) // емитируем значение
        // Для индикации номера отправляемого объекта добавленна переменная-счетчик i, которая
        // увеличивается при переходе к другому объекту списка. Вывод номера отправляемого объекта
        // позволяет увидеть, что получение внешним кодом объектов из списка происходит по мере его
        // передачи в поток с помощью функции emit(), а не когда будут отправлены все объекты из списка
        i++
    }
}

