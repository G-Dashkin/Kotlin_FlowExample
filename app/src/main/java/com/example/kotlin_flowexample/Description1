Суть Flow

Какая либо коллекция (например List) – это просто объект с набором данных.
Если мы вызываем какие то методы, типа .filter {}, .map {} или .forEach {} то по своей сути это просто
циклы в которых выполняются какие то действия для всех элементов прежде чем перейти к следующим операторам.

Flow - это именно поток данных позволяющий работать последовательно с каждым элементом в потоке.

Чтобы запустить в работу поток данных, нужно понимать различие промежуточных операторов и терминальных операторов.
Терминальные операторы – представляют собой какое-то завершающее действие в конце этого потока (например .forEach{})
Промежуточных операторы - выполняют действия с объектами в потоке.
Потоки данных выполняют свою работу, только если был вызов терминальный оператор.

Бывают холодные и горячие.

функция .collect{} является suspend-функцией. Она приостанавливает корутину до тех пор пока все данные из
потока не будут обработаны. И дальнейший код (т.е. второй вызов .collect{}) не будет выполняться до тех
пока в консоль не будут выведены 100 чисел. Только после этого начнет выполняться второй

Чтобы оба метода выполнялись одновременно их можно запустить в разных корутинах.
Для этого мы можем создать CoroutineScope и дважды вызвать функцию .launch{}

Холодные потоки (StateFlow)
Когда мы создаем поток через flow{}-билдер, то он является холодным. У холодных observable-объектов (или у
холодных потоков) есть несколько особенностей.

Во-первых такие объекты не будут эмитеть данные, пока на них никто не подпишется. т.е. пока не будет вызван
терминальный оператор. Если мы уберем вызов функции .collect{}, то какие бы промежуточные операторы мы не
вызывали (например .onCompletion{}), они не будут выполняться так как терминальный оператор не был вызван.

Во-вторых – на каждую подписку (на каждый вызов .collect{} или другого терминального оператора) у нас
создается новый Flow и если мы 10 раз подпишемся на тот же самый объект Flow, то для каждой подписке будет
создан новый поток данных и он будет эмитить свои значения для каждого Flow -коллектора.

В-третьих - если какому-то коллектору данные больше не нужны и он перестает их принимать то и поток
прекратит свое выполнение.

Итак,
-пока нет подписки, Flow не будет выполняться
-на каждую подписку создается новый поток данных
-если какой то Flow-коллектор перестает принимать данные, то и Flow прекращает свою работу.


Горячие потоки (SharedFlow)
Горячие потоки, создаются при помощи при помощи одной из реализаций интерфейста SharedFlow,
наприме MutableSharedFlow с указанием типа - MutableSharedFlow<Int>()

Первая особенность
В холодных потоках нам приходилось эмитить значения внтри потока, а снаружи мы уже не могли этого сделать
Снаружи можно было только подписываться на поток при помощи .collect{} и добавлять промежуточные операторы.
На горячие потоки также можно подписываться и вызывать у них промежуточные операторы, но кроме этого мы
можем эмитеть данные в этот Flow из любого места программы.
Итак, горячие потоки в отличие от холодных “шерятся” между под подписчиками. Отсюда и название
ШеардFlow (SharedFlow) т.е. все подписчики получают одни и те же элементы и работают с одним и тем же
потоком данных. В случае с холодными Flow каждый новый коллектор получал свои элементы. И для каждого
элемента создавался свой поток данных.

Вторая особенность - эти потоки эмитят данные несмотря на то есть подписчики или нет.

Третья особенность - если подписчикам больше не нужны данные, то холодный Flow завершал свое выполнение,
но в случае с горячими Flow этого не произойдет.
Также горячие потоки не завершаются, если эмитов больше нет. Причина в том, что объект SharedFlow может быть
в каком-то репозитории и программа не знает в какой момент мы захотим положить в него какое то значение.
Это может произойти в любой момент работы программы.Поэтому такой Flow не завершается никогда.


Итак, отличие холодных потоков от горячих
Первое
- холодный Flow эмитит значение только если на них кто то подписался.
- горячий Flow эмитит значение независимо от того есть подписчики или нет
Второе
- при каждой подписки создается на холодный Flow создается новый поток данных,
- при подписке на горячий Flow этого не происходит и все подписчики будут получать одни и те же элементы.
Третье
- если у холодный Flow подписчикам больше не нужны данные, то они завершают свою работу.
- горячие Flowг продолжат эмитить данные независимо от того нужны эти данные подписчикам или нет
Четвертое
- если в холодном Flow больше нет данных, то он завершают свою работу.
- горячие Flowг не завершается никогда